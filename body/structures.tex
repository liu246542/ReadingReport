% !Tex root = ../main.tex

\chapter{新型数据结构}

在这一章，我们将重点介绍由布隆过滤器衍生出来的几个特殊数据结构，分别是布谷鸟过滤器，异或型过滤器以及不经意的键值存储。
% 从上一章的分类我们知道，对于

\section{布谷鸟过滤器}

从上一章的分类我们可以知道，布谷鸟过滤器是一种 OR 型的过滤器，且 $f(x)$ 为 $x$ 的指纹信息。
布谷鸟过滤器的概念最早是由 Fan 等人~\cite{fan2014cuckoo} 于2014年提出的，其构造方式受到了布谷鸟哈希表（Cuckoo Hash Table）~\cite{pagh2004cuckoo}的启发。
在介绍布谷鸟过滤器之前，我们首先介绍布谷鸟哈希表的构造。

\subsection{布谷鸟哈希表}

布谷鸟哈希表可以看作一个由多个桶（bucket）组成的数组结构。
对于每个元素 $x$ 来说，它在哈希表中对应两个候选位置，分别由两个哈希函数 $h_1(x)$ 和 $h_2(x)$ 决定。
在插入元素 $x$ 时，首先检查 $x$ 对应的两个位置上的桶中是否有多余位置。
如果两个桶都有多余空间，则直接将 $x$ 放入桶中；如果两个桶都已满，则随机在一个候选位置上踢出一个元素并将 $x$ 放入该位置上。踢出的元素则重新插入到它对应的另一个候选位置上。
如图所示，假设每个桶中都只能存储一个元素，当插入元素 $x$ 时，首先计算出它的两个候选位置分别是 $2$ 和 $6$。
因为 $2$ 和 $6$ 两个位置都已满，这里选择踢出位置 $6$ 上的元素 $a$，并将 $x$ 放入其中。
被踢出的 $a$ 则重新插入到它的另一个候选位置，也就是 $4$ 上。
由于位置 $4$ 上已有元素 $c$，则把 $c$ 踢出，将 $a$ 存储在位置 $4$ 中，并将 $c$ 重新插入到它的候选位置 $1$ 上，最终结果如图所示。
这种``踢出-插入''的思路与布谷鸟下蛋时会将蛋放入其他鸟的巢穴，并挤出原本巢中蛋的行为很相似，因此而得名。

\subsection{布谷鸟过滤器的构造}

与布谷鸟哈希表类似，布谷鸟过滤器也是由多个桶组成的数组结构。
不同的是，在布谷鸟过滤器中每个桶中存储的并不是元素本身，而是元素的指纹。
这就导致在将桶中的元素指纹踢出时，无法根据指纹信息确定它的另一个候选位置。
因此布谷鸟过滤器采用了部分密钥布谷鸟哈希（partial-key cuckoo hashing）的技巧来解决该问题。
也就是将元素的两个候选位置与元素的指纹值建立联系，这样就能在只知道元素的指纹值和其中一个位置信息的情况下计算出另一个位置信息。
具体来说，对于元素 $x$，其对应的两个候选位置计算如下：
\begin{align}
  h_1(x) & = \mathsf{hash}(x) \\
  h_2(x) & = h_1(x) \oplus \mathsf{hash}(x\mbox{'s fingerprint}) \label{eq:cuckoo_h2}
\end{align}
式~\ref{eq:cuckoo_h2}中的异或操作正好满足了上述性质，即$h_1(x)$ 也可以通过 $h_2(x)$ 和 $x$ 的指纹信息计算得出。
另外，在异或操作中采用的是$x$指纹的哈希而不是$x$的指纹本身，这样做是因为如果只用指纹本身的话，两个候选位置之间的距离就受限于指纹的取值范围。
比如使用 $8$ 比特长度的指纹，那么两个候选位置之间最多相差 $256$。
而使用指纹的哈希则可以确保两个候选位置可以分布在过滤器中的任意位置，从而降低哈希碰撞的概率并提高存储空间的利用率。

\subsection{布谷鸟过滤器的性能}



\section{异或型过滤器}


\section{不经意的键值存储}


% !Tex root = ../main.tex

\chapter{简介}

\section{布隆过滤器}

在构造网络安全协议时，我们通常会使用到许多不同类型的数据结构。
其中，布隆过滤器作为一种经典的数据结构，在诸如隐私集合求交、可搜索加密、隐私信息检索等密码学协议中有着广泛的应用。
布隆过滤器是一种用于快速判断元素是否存在于某一集合的数据结构，它具有空间效率高、判断速度快的特点。
以大小为 $n$ 的集合 $S$ 为例，对应的布隆过滤器构造只需要 $O(n)$ 的存储开销以及 $O(1)$ 的判断复杂度。
% 但是布隆过滤器也并不是
布隆过滤器的构造如下图所示，它是使用 $k$ 个哈希函数 $\{h_1,\dots, h_k\}$ 构造的哈希表结构。
布隆过滤器上分为插入（Insert）和查找（Lookup）两个算法，
在构造过程中，对于每个在集合 $S$ 中的元素 $x$，首先使用这 $k$ 个哈希函数计算出 $k$ 个位置，然后对过滤器中该位置上的比特置为 $1$。
在判断元素是否属于集合 $S$ 时，只需要通过哈希函数计算该元素的 $k$ 个位置，然后检查过滤器上这 $k$ 个位置上的比特是否全为 $1$。
如果是，返回 True，否则返回 False。
从布隆过滤器的构造可以看出，

% 假定有一个集合 $S$，其大小 $|S| = n$，

文献\cite{luo2019optimizing}：

布隆过滤器（Bloom filter，BF）是一种空间效率高的概率型数据结构，它可以用来快速判断元素是否属于某一集合。
布隆过滤器是由 0-1 比特组成的比特向量结构，包含插入（Insert）和查找（Lookup）两个基本算法。
以包含 $n$ 个元素的集合 $S=\{x_1, x_2, \dots, x_n\}$ 为例，假设构造的布隆过滤器长度为 $m$，使用的哈希函数为 $\{h_1, h_2, \dots, h_k\}$，其中每个哈希函数 $h_i:\{0,1\}^* \to [0, m-1]$ 为任意长度的输入到布隆过滤器上某一位置的映射。
首先我们将布隆过滤器 $m$ 个位置上的比特都置为 $0$，然后再插入集合 $S$ 中的每一个元素。
在插入元素 $x$ 时，需要使用 $k$ 个哈希函数计算出 $k$ 个位置信息，即 $\{h_1(x),h_2(x),\dots, h_k(x)\}$。
再将布隆过滤器上这 $k$ 个位置上的比特都置为 $1$。
% 一个包含 $n$ 个元素的集合，
在判断某个元素是否属于集合 $S$ 时，只需要计算该元素对应的 $k$ 个位置，然后检查这 $k$ 个位置上的比特是否都为 $1$。
只要有一个位置上出现了 $0$，那么判断结果就是不属于；否则，布隆过滤器认为该元素属于集合 $S$。

从布隆过滤器的构造和判断算法中可以看出，如果一个元素属于集合 $S$，那么判断结果一定是正确的；但是如果一个元素不属于集合 $S$ （False的情况），布隆过滤器也有可能会认为该元素属于 $S$（输出结果为Positive），此时判断错误的概率也称为误判率（False Positive Rate）。
尽管布隆过滤器存在误判的问题，但在实际应用场景中，只要将误判率控制在较小的值，一般认为以一定的误判换取低空间开销和高效判断是值得的。

布隆过滤器的误判率 $f_r$ 由布隆过滤器的长度 $m$，使用的哈希函数个数 $k$ 和集合中的元素个数 $n$ 所决定。
理论上，误判率 $f_r$ 与它们的关系如公式~\eqref{eq:BF_FPR}所示：
\begin{equation}
    f_r = \left[ 1 - \left( 1 - \frac{1}{m} \right)^{nk} \right]^k \approx \left(1 - e^{-\frac{kn}m{}}\right)^k,
    \label{eq:BF_FPR}
\end{equation}
其中，$(1-1/m)^{nk}$ 近似成 $e^{-kn/m}$ 的形式。
为了尽可能降低误判率 $f_r$，那么就需要尽可能降低 $e^{-kn/m}$ 的值，这样一来，$k$ 的最优取值为：
\begin{equation}
    k_{opt}= \frac{m}{n}\ln 2 \approx \frac{9m}{13n}.
    \label{eq:BF_k}
\end{equation}
此时，误判率大约为 $0.5^k\approx 0.6185^{m/n}$。
通常在实际应用中的误判率要比理论分析上的更高。也有一些工作对误判率做了更精确的刻画。

布隆过滤器本身是不支持删除的，因为如果是简单将需要删除元素所对应位置的比特置为 $0$，那么就会对其他元素的判断造成影响。

布隆过滤器的高效体现在两个方面：
\begin{itemize}
    \item 空间利用率：布隆过滤器的大小与元素的大小无关，只与集合中元素的数量有关。比如，当给定 $m$ 与 $n$ 的比值为 $5$ 时，根据公式~\eqref{eq:BF_k} 可以计算出需要的哈希函数数量为 $3$ 或 $4$。因为布隆过滤器中每个位置上存储的都是比特，所以整体长度也就是 $m$ 比特。
    \item 恒定时间的查询时间：因为只需要检查 $k$ 个位置上的比特是否全为 $1$，因此检查一个元素的时间复杂度为 $O(k)$。相比于树形结构的查询效率（$O(\log(n))$）或列表结构的查询效率（$O(n)$）都要高。而对于具体的布隆过滤器实例来说，$k$ 的值在初始化阶段就是常数，因此插入和查询的复杂度都为 $O(1)$。
    \item 无漏判：尽管布隆过滤器在查询时会存在误判的情况，但是它不会出现漏判（假阴性）的情况。也就是只要是布隆过滤器判断元素 $x$ 不属于 $S$，那么该论断一定是正确的。
\end{itemize}

布隆过滤器的挑战性问题：

\section{分类}

这里引用文献~\cite{2024YinSiJiHeYunSuanZhongDeGuanJianShuJuJieGouYanJiu}
